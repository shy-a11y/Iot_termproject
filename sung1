import pcap
import dpkt
import keyboard
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.artist import Artist

BANDWIDTH = 20
NSUB = int(BANDWIDTH * 3.2)
selected_mac = 'd83add07f767'
show_packet_length = 100
GAP_PACKET_NUM = 20

def truncate(num, n):
    integer = int(num * (10 ** n)) / (10 ** n)
    return float(integer)

def sniffing(nicname, mac_address):
    print('Start Sniffing... @', nicname, 'UDP, Port 5500')
    sniffer = pcap.pcap(name=nicname, promisc=True, immediate=True, timeout_ms=50)
    sniffer.setfilter('udp and port 5500')

    before_ts = 0.0

    x = np.arange(0, show_packet_length, 1)
    y_list = [[0 for _ in range(show_packet_length)] for _ in range(NSUB)]

    plt.ion()
    fig, ax = plt.subplots(figsize=(12, 8))

    line_list = [ax.plot(x, y, alpha=0.5)[0] for y in y_list]
    plt.title('{}'.format(selected_mac), fontsize=18)
    plt.ylabel('Signal Amplitude', fontsize=16)
    plt.xlabel('Packet', fontsize=16)
    plt.ylim(0, 1500)

    txt = ax.text(40, 1600, 'Amp Min-Max Gap: None', fontsize=14)
    alert_txt = ax.text(40, 1400, '', fontsize=14, color='red')
    gap_count = 0
    minmax = []

    idx = show_packet_length - 1

    # 추가: 변화 감지를 위한 변수 초기화
    mean_list = np.zeros(NSUB)
    std_list = np.zeros(NSUB)
    threshold = 3  # 표준편차 임계값

    for ts, pkt in sniffer:
        if int(ts) == int(before_ts):
            cur_ts = truncate(ts, 1)
            bef_ts = truncate(before_ts, 1)
            if cur_ts == bef_ts:
                before_ts = ts
                continue

        try:
            eth = dpkt.ethernet.Ethernet(pkt)
            ip = eth.data
            udp = ip.data
            mac = udp.data[4:10].hex()
        except Exception as e:
            print(f"Error parsing packet: {e}")
            continue

        if mac != mac_address:
            continue

        csi = udp.data[18:]
        nsub = int(BANDWIDTH * 3.2)

        csi_np = np.frombuffer(csi, dtype=np.int16, count=nsub * 2)
        csi_np = csi_np.reshape((1, nsub * 2))
        csi_cmplx = np.fft.fftshift(csi_np[:1, ::2] + 1.j * csi_np[:1, 1::2], axes=(1,))
        csi_data = list(np.abs(csi_cmplx)[0])

        idx += 1
        change_detected = False  # 변화 감지 여부 플래그

        for i, y in enumerate(y_list):
            del y[0]
            new_y = csi_data[i]
            y.append(new_y)
            line_list[i].set_xdata(x)
            line_list[i].set_ydata(y)

            if gap_count == 0:
                minmax.append([new_y, new_y])
                mean_list[i] = np.mean(y)
                std_list[i] = np.std(y)
            else:
                if minmax[i][0] > new_y:
                    minmax[i][0] = new_y
                if minmax[i][1] < new_y:
                    minmax[i][1] = new_y
                
                # 변화 감지
                if abs(new_y - mean_list[i]) > threshold * std_list[i]:
                    change_detected = True

        if change_detected:
            for line in line_list:
                line.set_color('red')
            alert_txt.set_text('Change Detected!')
        else:
            for line in line_list:
                line.set_color('blue')
            alert_txt.set_text('')

        gap_list = [mm[1] - mm[0] for mm in minmax]
        gap = max(gap_list)

        Artist.remove(txt)
        txt = ax.text(40, 1600, 'Amp Min-Max Gap: {}'.format(gap), fontsize=14)
        gap_count += 1
        if gap_count == 20:
            gap_count = 0
            minmax = []

        fig.canvas.draw()
        fig.canvas.flush_events()

        before_ts = ts

        if keyboard.is_pressed('s'):
            print("Stop Collecting...")
            break

if __name__ == '__main__':
    sniffing('wlan0', selected_mac)
